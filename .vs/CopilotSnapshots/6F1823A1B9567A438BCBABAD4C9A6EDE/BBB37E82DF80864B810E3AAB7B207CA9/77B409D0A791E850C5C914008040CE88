using ModelContextProtocol.Server;
using System.ComponentModel;
using System.Text.Json;
using TimeTrackerMcp.Models;
using TimeTrackerMcp.Services;

namespace TimeTrackerMcp.Tools;

/// <summary>
/// MCP tools for time tracking functionality.
/// </summary>
[McpServerToolType]
public static class TimeTools
{
    /// <summary>
    /// Gets the current system time in the requested format and timezone.
    /// </summary>
    /// <param name="timeZoneResolver">Injected timezone resolver service.</param>
    /// <param name="format">Output format: 'iso8601' (default), 'unix', 'unix_ms', 'friendly'</param>
    /// <param name="timezone">IANA timezone name (e.g., 'America/New_York', 'UTC'). Defaults to 'local'.</param>
    /// <returns>TimeResult with timestamp, timezone, and UTC offset.</returns>
    [McpServerTool]
    [Description("Returns the current system date and time. Supports multiple formats and timezones.")]
    public static string time_get_current(
        ITimeZoneResolver timeZoneResolver,
        [Description("Output format. Options: 'iso8601' (default), 'unix', 'unix_ms', 'friendly'")]
        string format = "iso8601",
        [Description("IANA timezone name (e.g., 'America/New_York', 'UTC'). Defaults to system local timezone.")]
        string timezone = "local")
    {
        // M1-012: Resolve timezone (defaults to 'local')
        var tzResult = timeZoneResolver.Resolve(timezone);
        if (!tzResult.Success)
        {
            return JsonSerializer.Serialize(new
            {
                error = true,
                error_code = tzResult.ErrorCode,
                error_message = tzResult.ErrorMessage
            });
        }

        var tz = tzResult.TimeZone!;
        var utcNow = DateTimeOffset.UtcNow;
        var localTime = TimeZoneInfo.ConvertTime(utcNow, tz);

        // M1-018: Compute UTC offset in ±HH:MM format
        var offset = tz.GetUtcOffset(utcNow);
        var utcOffset = FormatUtcOffset(offset);

        // M1-011, M1-013-M1-017: Format timestamp based on format parameter
        string timestamp;
        switch (format.ToLowerInvariant())
        {
            // M1-013: ISO 8601 format
            case "iso8601":
                timestamp = localTime.ToString("o"); // ISO 8601 with offset
                break;

            // M1-014: Unix timestamp (seconds since epoch)
            case "unix":
                timestamp = utcNow.ToUnixTimeSeconds().ToString();
                break;

            // M1-015: Unix timestamp (milliseconds since epoch)
            case "unix_ms":
                timestamp = utcNow.ToUnixTimeMilliseconds().ToString();
                break;

            // M1-016: Friendly format
            case "friendly":
                timestamp = localTime.ToString("MMMM d, yyyy h:mm:ss tt");
                break;

            // M1-017: Unknown format error
            default:
                return JsonSerializer.Serialize(new
                {
                    error = true,
                    error_code = "UNKNOWN_FORMAT",
                    error_message = $"Unknown format: '{format}'. Valid options are: 'iso8601', 'unix', 'unix_ms', 'friendly'."
                });
        }

        // Return successful result
        var result = new TimeResult
        {
            Timestamp = timestamp,
            Timezone = tz.Id,
            UtcOffset = utcOffset
        };

        return JsonSerializer.Serialize(result);
    }

    /// <summary>
    /// Formats a TimeSpan offset as ±HH:MM string.
    /// </summary>
    private static string FormatUtcOffset(TimeSpan offset)
    {
        var sign = offset >= TimeSpan.Zero ? "+" : "-";
        var absOffset = offset.Duration();
        return $"{sign}{absOffset.Hours:D2}:{absOffset.Minutes:D2}";
    }
}
