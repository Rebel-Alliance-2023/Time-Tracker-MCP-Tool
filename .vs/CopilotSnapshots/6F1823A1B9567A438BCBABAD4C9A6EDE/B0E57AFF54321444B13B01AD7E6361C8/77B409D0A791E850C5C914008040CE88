using ModelContextProtocol.Server;
using System.ComponentModel;
using System.Text.Json;
using TimeTrackerMcp.Models;
using TimeTrackerMcp.Services;

namespace TimeTrackerMcp.Tools;

/// <summary>
/// MCP tools for time tracking functionality.
/// </summary>
[McpServerToolType]
public static class TimeTools
{
    /// <summary>
    /// Gets the current system time in the requested format and timezone.
    /// </summary>
    /// <param name="timeZoneResolver">Injected timezone resolver service.</param>
    /// <param name="format">Output format: 'iso8601' (default), 'unix', 'unix_ms', 'friendly'</param>
    /// <param name="timezone">IANA timezone name (e.g., 'America/New_York', 'UTC'). Defaults to 'local'.</param>
    /// <returns>TimeResult with timestamp, timezone, and UTC offset.</returns>
    [McpServerTool]
    [Description("Returns the current system date and time. Supports multiple formats and timezones.")]
    public static string time_get_current(
        ITimeZoneResolver timeZoneResolver,
        [Description("Output format. Options: 'iso8601' (default), 'unix', 'unix_ms', 'friendly'")]
        string format = "iso8601",
        [Description("IANA timezone name (e.g., 'America/New_York', 'UTC'). Defaults to system local timezone.")]
        string timezone = "local")
    {
        // M1-012: Resolve timezone (defaults to 'local')
        var tzResult = timeZoneResolver.Resolve(timezone);
        if (!tzResult.Success)
        {
            return JsonSerializer.Serialize(new
            {
                error = true,
                error_code = tzResult.ErrorCode,
                error_message = tzResult.ErrorMessage
            });
        }

        var tz = tzResult.TimeZone!;
        var utcNow = DateTimeOffset.UtcNow;
        var localTime = TimeZoneInfo.ConvertTime(utcNow, tz);

        // M1-018: Compute UTC offset in ±HH:MM format
        var offset = tz.GetUtcOffset(utcNow);
        var utcOffset = FormatUtcOffset(offset);

        // M1-011, M1-013-M1-017: Format timestamp based on format parameter
        string timestamp;
        switch (format.ToLowerInvariant())
        {
            // M1-013: ISO 8601 format
            case "iso8601":
                timestamp = localTime.ToString("o"); // ISO 8601 with offset
                break;

            // M1-014: Unix timestamp (seconds since epoch)
            case "unix":
                timestamp = utcNow.ToUnixTimeSeconds().ToString();
                break;

            // M1-015: Unix timestamp (milliseconds since epoch)
            case "unix_ms":
                timestamp = utcNow.ToUnixTimeMilliseconds().ToString();
                break;

            // M1-016: Friendly format
            case "friendly":
                timestamp = localTime.ToString("MMMM d, yyyy h:mm:ss tt");
                break;

            // M1-017: Unknown format error
            default:
                return JsonSerializer.Serialize(new
                {
                    error = true,
                    error_code = "UNKNOWN_FORMAT",
                    error_message = $"Unknown format: '{format}'. Valid options are: 'iso8601', 'unix', 'unix_ms', 'friendly'."
                });
        }

        // Return successful result
        var result = new TimeResult
        {
            Timestamp = timestamp,
            Timezone = tz.Id,
            UtcOffset = utcOffset
        };

        return JsonSerializer.Serialize(result);
    }

    // M2-032: Implement time_session_start tool
    /// <summary>
    /// Starts a new time tracking session for a milestone.
    /// </summary>
    [McpServerTool]
    [Description("Starts a new time tracking session for a milestone. Returns session ID and start time.")]
    public static string time_session_start(
        ISessionService sessionService,
        // M2-033: Required parameters
        [Description("Unique identifier for the milestone being tracked (required).")]
        string milestone_id,
        [Description("List of task IDs to track in this session (required). Format: comma-separated or JSON array.")]
        string task_ids,
        // M2-034: Optional parameters
        [Description("Human-readable name for the milestone (optional).")]
        string? milestone_name = null,
        [Description("IANA timezone name for timestamps. Defaults to 'local'.")]
        string? timezone = null,
        [Description("Additional metadata as JSON object (optional).")]
        string? metadata = null,
        [Description("Tags for categorization as comma-separated list (optional).")]
        string? tags = null)
    {
        // Parse task_ids (support comma-separated or JSON array)
        List<string> taskIdList;
        try
        {
            if (task_ids.TrimStart().StartsWith("["))
            {
                taskIdList = JsonSerializer.Deserialize<List<string>>(task_ids) ?? new List<string>();
            }
            else
            {
                taskIdList = task_ids.Split(',', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries).ToList();
            }
        }
        catch
        {
            return JsonSerializer.Serialize(new
            {
                error = true,
                error_code = "INVALID_TASK_IDS",
                error_message = "task_ids must be a comma-separated list or JSON array of task IDs."
            });
        }

        // Parse metadata if provided
        Dictionary<string, string>? metadataDict = null;
        if (!string.IsNullOrWhiteSpace(metadata))
        {
            try
            {
                metadataDict = JsonSerializer.Deserialize<Dictionary<string, string>>(metadata);
            }
            catch
            {
                return JsonSerializer.Serialize(new
                {
                    error = true,
                    error_code = "INVALID_METADATA",
                    error_message = "metadata must be a valid JSON object with string values."
                });
            }
        }

        // Parse tags if provided
        List<string>? tagsList = null;
        if (!string.IsNullOrWhiteSpace(tags))
        {
            tagsList = tags.Split(',', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries).ToList();
        }

        // Start the session
        var result = sessionService.StartSession(
            milestoneId: milestone_id,
            taskIds: taskIdList,
            milestoneName: milestone_name,
            timezone: timezone,
            metadata: metadataDict,
            tags: tagsList);

        if (!result.Success)
        {
            return JsonSerializer.Serialize(new
            {
                error = true,
                error_code = result.ErrorCode,
                error_message = result.ErrorMessage
            });
        }

        var session = result.Session!;

        // M2-035: Return session response
        return JsonSerializer.Serialize(new
        {
            session_id = session.SessionId,
            milestone_id = session.MilestoneId,
            milestone_name = session.MilestoneName,
            start_time = session.StartTime.ToString("o"),
            start_time_friendly = session.StartTime.ToString("MMMM d, yyyy h:mm:ss tt"),
            task_count = session.TaskIds.Count,
            timezone = session.Timezone,
            tags = session.Tags,
            metadata = session.Metadata
        });
    }

    // M2-036: Implement time_session_end tool
    /// <summary>
    /// Ends a time tracking session and returns the summary.
    /// </summary>
    [McpServerTool]
    [Description("Ends a time tracking session and returns the full summary with duration and task breakdown.")]
    public static string time_session_end(
        ISessionService sessionService,
        // M2-037: Required and optional parameters
        [Description("The session ID to end (required).")]
        string session_id,
        [Description("Include detailed task breakdown in response. Defaults to true.")]
        bool include_task_details = true)
    {
        // M2-039: Handle session not found
        var result = sessionService.EndSession(session_id);

        if (!result.Success)
        {
            return JsonSerializer.Serialize(new
            {
                error = true,
                error_code = result.ErrorCode,
                error_message = result.ErrorMessage
            });
        }

        // M2-038: Return full session summary
        return BuildSessionSummaryResponse(result.Session!, include_task_details, isEnded: true);
    }

    // M2-040: Implement time_session_summary tool
    /// <summary>
    /// Gets the current status of an active session without ending it.
    /// </summary>
    [McpServerTool]
    [Description("Gets the current status and summary of an active session without ending it.")]
    public static string time_session_summary(
        ISessionService sessionService,
        [Description("The session ID to get summary for (required).")]
        string session_id,
        [Description("Include detailed task breakdown in response. Defaults to true.")]
        bool include_task_details = true)
    {
        var result = sessionService.GetSessionSummary(session_id);

        if (!result.Success)
        {
            return JsonSerializer.Serialize(new
            {
                error = true,
                error_code = result.ErrorCode,
                error_message = result.ErrorMessage
            });
        }

        // M2-041: Return same structure as time_session_end but session remains active
        return BuildSessionSummaryResponse(result.Session!, include_task_details, isEnded: false);
    }

    /// <summary>
    /// Builds a session summary response JSON.
    /// </summary>
    private static string BuildSessionSummaryResponse(Session session, bool includeTaskDetails, bool isEnded)
    {
        // Calculate task counts
        var tasksCompleted = session.Tasks.Count(t => t.Status == Models.TaskStatus.Completed);
        var tasksSkipped = session.Tasks.Count(t => t.Status == Models.TaskStatus.Skipped);
        var tasksInProgress = session.Tasks.Count(t => t.Status == Models.TaskStatus.InProgress);
        var tasksNotStarted = session.Tasks.Count(t => t.Status == Models.TaskStatus.NotStarted);
        var tasksRemaining = tasksInProgress + tasksNotStarted;

        // Calculate duration
        long? durationMs = session.GetDurationMs();
        long elapsedMs = session.GetElapsedMs();
        var effectiveDurationMs = durationMs ?? elapsedMs;

        // Build response object
        var response = new Dictionary<string, object?>
        {
            ["session_id"] = session.SessionId,
            ["milestone_id"] = session.MilestoneId,
            ["milestone_name"] = session.MilestoneName,
            ["is_ended"] = isEnded,
            ["start_time"] = session.StartTime.ToString("o"),
            ["start_time_friendly"] = session.StartTime.ToString("MMMM d, yyyy h:mm:ss tt"),
            ["end_time"] = session.EndTime?.ToString("o"),
            ["end_time_friendly"] = session.EndTime?.ToString("MMMM d, yyyy h:mm:ss tt"),
            ["duration_ms"] = effectiveDurationMs,
            ["duration"] = FormatDuration(effectiveDurationMs),
            ["timezone"] = session.Timezone,
            ["task_count"] = session.TaskIds.Count,
            ["tasks_completed"] = tasksCompleted,
            ["tasks_skipped"] = tasksSkipped,
            ["tasks_in_progress"] = tasksInProgress,
            ["tasks_not_started"] = tasksNotStarted,
            ["tasks_remaining"] = tasksRemaining,
            ["tags"] = session.Tags,
            ["metadata"] = session.Metadata
        };

        // Include task details if requested
        if (includeTaskDetails)
        {
            var taskDetails = session.Tasks.Select(t => new Dictionary<string, object?>
            {
                ["task_id"] = t.TaskId,
                ["task_name"] = t.TaskName,
                ["status"] = t.Status,
                ["start_time"] = t.StartTime?.ToString("o"),
                ["end_time"] = t.EndTime?.ToString("o"),
                ["duration_ms"] = t.DurationMs,
                ["duration"] = t.DurationMs.HasValue ? FormatDuration(t.DurationMs.Value) : null,
                ["metadata"] = t.Metadata
            }).ToList();

            response["tasks"] = taskDetails;
        }

        return JsonSerializer.Serialize(response);
    }

    /// <summary>
    /// Formats a duration in milliseconds as a human-readable string.
    /// </summary>
    private static string FormatDuration(long milliseconds)
    {
        var span = TimeSpan.FromMilliseconds(milliseconds);

        if (span.TotalSeconds < 1)
            return "less than 1 second";

        var parts = new List<string>();

        if (span.Hours > 0)
            parts.Add($"{span.Hours} hour{(span.Hours != 1 ? "s" : "")}");

        if (span.Minutes > 0)
            parts.Add($"{span.Minutes} minute{(span.Minutes != 1 ? "s" : "")}");

        if (span.Seconds > 0)
            parts.Add($"{span.Seconds} second{(span.Seconds != 1 ? "s" : "")}");

        return string.Join(" ", parts);
    }

    /// <summary>
    /// Formats a TimeSpan offset as ±HH:MM string.
    /// </summary>
    private static string FormatUtcOffset(TimeSpan offset)
    {
        var sign = offset >= TimeSpan.Zero ? "+" : "-";
        var absOffset = offset.Duration();
        return $"{sign}{absOffset.Hours:D2}:{absOffset.Minutes:D2}";
    }
}
